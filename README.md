# เส้นทางในสอวน. คอมพิวเตอร์ ของ opal_Inwza007x 
 
## สารบัญ
- [การเริ่มต้น](https://github.com/opalInwza007x/TEST/blob/main/README.md#%E0%B8%81%E0%B8%B2%E0%B8%A3%E0%B9%80%E0%B8%A3%E0%B8%B4%E0%B9%88%E0%B8%A1%E0%B8%95%E0%B9%89%E0%B8%99)

- [ค่าย 1](https://github.com/opalInwza007x/TEST/blob/main/README.md#%E0%B8%84%E0%B9%88%E0%B8%B2%E0%B8%A2-1)

- [ช่วงโดนตบก่อนไปค่าย 2](https://github.com/opalInwza007x/TEST/blob/main/README.md#%E0%B8%8A%E0%B9%88%E0%B8%A7%E0%B8%87%E0%B9%82%E0%B8%94%E0%B8%99%E0%B8%95%E0%B8%9A%E0%B8%81%E0%B9%88%E0%B8%AD%E0%B8%99%E0%B9%84%E0%B8%9B%E0%B8%84%E0%B9%88%E0%B8%B2%E0%B8%A2-2)

- [ค่าย 2](https://github.com/opalInwza007x/TEST/blob/main/README.md#%E0%B8%84%E0%B9%88%E0%B8%B2%E0%B8%A2-2)

- [The 19th Thailand Olympiad in Informatics](https://github.com/opalInwza007x/TEST/blob/main/README.md#the-19th-thailand-olympiad-in-informatics)

- [จุดจบ](https://github.com/opalInwza007x/TEST/blob/main/README.md#%E0%B8%88%E0%B8%B8%E0%B8%94%E0%B8%88%E0%B8%9A)
 
สวัสดีผู้อ่านทุกท่านครับ พวกคุณเคยสนใจเรื่องสอวน. คอมพิวเตอร์กันไหมครับ?

ขอกราบสวัสดีกันอีกรอบครับ ผมชื่อเล่นชื่อ "โอปอ" นะครับ แต่ในวงการนี้หลายๆคนคงรู้จักผมในนาม "opal_Inwza007x" เนื่องจากผมพึ่งผ่านประสบการณ์ที่แสนจะสนุกสนาน(?)ในค่ายนี้มา ผมเลยอยากจะมาช่วยยกระดับพื้นฐานของผู้คนที่สนใจในสอวน. คอมพิวเตอร์กันสักหน่อย 

ในการเข้าค่ายโอลิมปิกคอมพิวเตอร์ ก็จะได้เรียนเกี่ยวกับพวก Competitive Programming อารมณ์ประมาณเขียนโปรแกรมเพื่อคำณวนอะไรสักอย่าง ส่วนใหญ่จะเน้นให้โค้ดเราทำงานได้ และทำให้โค้ดเราเร็วขึ้น เพราะฉะนั้นพอผมไปเข้าค่ายแล้ว ผมก็ยังไม่สามารถซ่อมอุปกรณ์ได้ทุกชนิดนะครับ555 

สำหรับในค่าย เนื้อหาหรือทฤษฎีส่วนใหญ่ในแต่ละเรื่องคงมีไม่กี่หน้ากระดาษหรอกครับ ที่ยากคือการเอาไปประยุกต์ใช้ ซึ่งเกิดจากการฝึกทำโจทย์บ่อยๆ แล้วในช่วงที่เราเจอทางตันด้านเนื้อหา จะรู้สึกค่อนข้างท้อเลย แต่ก็จะยังมีพี่ๆค่ายหรือ blog ของหลายๆคน คอยช่วยชี้ทางทำให้ผมได้เข้าใจและพัฒนาขึ้นจนถึงจุดนี้ ผมเลยอยากจะมาสร้าง blog สรุปเนื้อหาของสอวน. คอมพิวเตอร์ ตามความเข้าใจของผม และหาโจทย์ในเรื่องนั้นๆมาให้ลองทำดูด้วย(ถ้าว่างจะทำ Editorial ให้ด้วยเลย :P) ที่คาดไว้คือ เนื้อหาคงจะถึง[คอมพิวเตอร์โอลิมปิกระดับชาติ](https://toi19.nu.ac.th/scope.php) เอาล่ะมาดูเรื่องราวของผมดีกว่า หวังว่าจะได้แรงผลักดันไม่มากก็น้อยนะครับ :)

## การเริ่มต้น

opal_Inwza007x ก็เป็นเด็กธรรมดาคนนึงที่เก่งคณิตนิดหน่อย จนกระทั้งได้ตกค่าย 1 ของสอวน. คอมพิวเตอร์ ตอนม.4 ในตอนที่ได้รู้ว่าตัวเองติดแค่ค่ายคอมพิวเตอร์ ก็รู้สึกเสียดายนิดๆเพราะมาสอบตามเพื่อน อยากเข้าคณิตมากกว่า บวกกับปีนั้นเป็นปีที่ได้เข้าค่ายในรูปแบบออนไลน์พอดี(โดนโควิดถล่ม T^T) ก็เลยไม่ได้ตั้งใจเรียนเลย แค่เข้าเรียนให้ครบเวลาไปวันๆ

ในบางวันอาจารย์ก็จะมี lab มาให้ทำด้วย เป็นการทดสอบว่าเด็กเรียนรู้เรื่องไหม ซึ่งถ้าเด็กคนไหนทำไม่ได้ ก็อาจจะได้อยู่กับอาจารย์ถึง 2 ทุ่มเลย แต่บางคนก็อาจจะโชคดีหน่อย ที่มีเส้นสายหรือช่องทางลับในการรับ code ที่ส่ง lab นั้นๆผ่าน ถึงแม้โค้ดนั้นจะไปก็อปมาอีกที แต่ก็ต้องขอขอบคุณมากครับ ไม่อย่างงั้นผมอาจจะทำไม่เสร็จสัก lab แล้วเกลียด coding ไปเลยก็ได้555 ซึ่งในค่ายนี้ขึ้นชื่อว่าเป็นค่ายโอลิมปิกวิชาการก็จะมีพวกเทพๆมาอยู่แน่นอน lab เปิดมาไม่ถึงนาทีก็เสร็จกันละ ผมเป็นเด็กใหม่ก็นั่งช็อคสิครับ แค่เรียนยังไม่รู้เรื่องเลย555

เมื่อเวลาผ่านไป จนถึงช่วงใกล้ๆจะสอบท้ายค่าย ผมก็มีความรู้สึกอยากได้ไปต่อค่าย 2 อยู่ ติดที่ว่าตอนอาจารย์สอนดันเล่นแต่เกม ตอนทำ lab ก็ดันไปก็อปแต่โค้ดชาวบ้านนี่สิ พอพยายามกลับไปอ่านโค้ดที่ตัวเองเก็บเอาไว้ กลับไม่เข้าใจสักอย่างเลย

    "รับค่าเข้ามา n ตัวมันทำยังไงวะ"
    
นั่นคือคำพูดสุดท้ายก่อนเขาจะไปนั่งสร้างตัวแปร a-z แล้วรับค่าเข้ามาทีละตัว เพราะใช้ loop ไม่เป็นเลย ซึ่งแน่นอนว่าตกค่ายครับ TwT

คราวหลังผมก็พึ่งมารู้ว่าถ้าแค่เขียนให้พอมีหลักการ ไม่ต้องมีคะแนนออก ก็ยังมีโอกาสที่จะได้ไปต่อ พอผมได้รู้ช่วงแรกๆ ผมก็ไม่ได้รู้สึกอะไรมากครับ ก็คิดไว้ว่า "นี่ไม่ใช่สายของเรา คงมาได้แค่นี้แหละ" และนี่ก็คงไม่ใช่วิชาที่ผมต้องใช้ในอนาคตสักหน่อย แต่ยิ่งเวลาผ่านไปนานเท่าไหร่ ผมยิ่งรู้สึกเจ็บใจมากขึ้นเท่านั้น ผมกลับคิดอยู่ตลอดว่า "ถ้าผมแค่พยายามมากกว่านี้อีกนิดหน่อยก็คงได้ไปต่อแล้ว" 

ผมทำเต็มที่แล้วรึยังนะ 

ยังสินะ...

งั้นมาเริ่มทำให้เต็มที่กันเลย!!! 

ในตอนนั้นผมจึงตัดสินใจที่จะพยายามไปจนถึงเมื่อถึงจุดจบ __จะไม่มีคำว่า "ยังไม่ได้ทำดีที่สุด"__ ออกมาจากความคิดผมอีกเลย จากคนที่แทบไม่เคยพยายามกับเรื่องเรียน กลายเป็นคนที่ทำโจทย์ทุกเวลาว่างที่มีโอกาส 
แม้ในตอนแรกมันไม่สนุกเอาซะเลย กว่าจะทำได้แต่ละข้อ ไม่รู้ว่าควรจะคิดแบบไหน หรือถ้าคิดได้แล้วก็ต้องมานั่งไล่ว่าทำไมถึงยังผิดอยู่ แต่เมื่อผมฝึกถึงจุดที่เข้าใจระดับนึง ความรู้สึกเวลาที่ได้เห็นตัวเองทำข้อที่เมื่อก่อนทำไม่ได้ ความรู้สึกที่ได้เห็นตัวเองพัฒนา ก็เริ่มเข้ามาแทรกความรู้สึกที่อยากติดค่ายเฉยๆ ทำให้การเรียนรู้แต่ละครั้งผลักดันผมให้ไปข้างหน้ามากกว่าครั้งไหนๆ ไม่รู้ว่าตั้งแต่เมื่อไหร่ จากที่แต่ก่อนเป็นคนที่ชอบเล่นเกมอยู่บ่อยๆ ตอนนี้การทำโจทย์มันสนุกกว่าการเล่นเกมเสียอีก 

ผ่านมาครึ่งปี ถึงเวลาที่จะไปสอบเข้าค่าย 1 ใหม่อีกรอบ 
ปีนั้นเป็นปีที่ตั้งใจที่จะลงโอลิมปิกคอมมากๆ แม้คราวก่อนจะเคยสอบติดไปแล้ว แต่รอบนี้กลับกดดันกว่าเดิม เนื่องจากในตอนนั้น opal_Inwza007x ดันฟิตเนื้อหาค่ายมากไป ทำให้ฝีมือคณิตศาสตร์ที่ต้องใช้สอบเข้าค่าย 1 ดรอบปลงพอสมควร ถ้าพลาดครั้งนี้ผมคงไม่มีโอกาสแก้ตัวอีก จะได้ไม่ได้ไม่รู้ แต่ทำเต็มที่แน่นอน!!!

ผลออกมาก็คือติดครับ แสดงว่าความสามารถผมน่าจะถึงอยู่แล้วแน่ๆเลย(โม้ว่ะ) เอาล่ะได้เวลาลองท้าทายค่ายวิชาการนี้ดูแล้ว...

## ค่าย 1 

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/83001b78-4b3c-4742-ad5f-fd24b0953df8.jpg)" width="500px" align="center">


ผมยู่ศูนย์สอวน. มหาวิทยาลัยขอนแก่นนะครับ ปีนั้นสอบติดที่ [สอวน. ค่าย 1 คอมพิวเตอร์ หนองบัวพิทยาคาร](https://www.facebook.com/profile.php?id=100086639358447) แล้วก็จะมีอีกที่คือ [สอวน. ค่าย 1 คอมพิวเตอร์ โรงเรียนแก่นนครวิทยาลัย](https://www.facebook.com/porn.comknw)

เป็นปีที่ได้กลับมาเรียนแบบออนไซต์ตามปกติ ถ้าใครมีโอกาสก็มาลงหนองบัวได้นะครับ recommend 300% สำหรับการกินดีอยู่ดี 

ในปีนั้นพวกมหาเทพของค่ายผม
ได้ไปอยู่สสวท. หมดแล้ว ส่วนใหญ่เลยมีแต่คนมาเปิดประสบการณ์ครั้งแรกสำหรับค่ายโอลิมปิกเลย ในค่ายนี้หลักๆก็มีเนื้อหาพื้นฐานภาษา C++ จะมีพวก

* input/output
* Variable
* Loop
* Array
* Vector
* Sort
* Set
* Function & Recursive Function
* Stack
* Struct
* Basic Algorithm

ชีวิตประจำวันในค่ายของคนปกติก็ ตื่นมากินข้าวสัก 7 โมงเช้า รถออกตอน 8 โมงกว่าๆ กลับที่พักสัก 5 โมงเย็น

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/c11a3975-da5a-4b25-be56-765552a8860d.jpg)" width="500px" align="center">

สำหรับอาหารช่วงเช้าถือว่า premium มากครับ ในทุกๆวันจะมีพวก เบคอน แฮม ไข่กระทะ ไส้กรอก กินได้แบบ unlimit(สำหรับคนที่มาทันนะ555) 
อาหารช่วงเบรคนี่อยากกินอะไรเขามีหมดครับ(ผมนี่แทบไปปิ้งหนมปังทาแยม กับกดโอวันติลทุกเบรคเลย) ข้าวเที่ยงนี่แทบขอได้ทุกอย่างเลยครับ ครูจัดให้ได้หมด ยกเว้นปลาเผานะ5555 ส่วนมื้อเย็นก็ใช้ได้นะครับ แค่กลัวใช้เงินที่ได้มาค่ายไม่ครบแล้วสั่งอาหารสุดหรูมากินแทน

ปีนั้นผมทำโจทย์มาเยอะพอสมควร เลยได้เป็น Debugger สำหรับเพื่อนและครู ผมสามารถทำได้ทุกอย่างในค่ายครับ ใครมาถามผมเหมือนได้เปิดเฉลยอ่านเลย ยกเว้นซะแต่ pattern ทำไมมันยากจัง!!??? หลังจบค่ายมาผมจึงได้ skill เทพ pattern พอสมควร 

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/f3d9bbad-d651-497a-801a-404eded708b7" width="500px" align="center">
>
> ว่างๆลองดูได้นะ เหอๆ

แล้วก็เวลาอยู่ที่พักในค่ายผมอยากให้ทุกคนระวัง item นึงไว้ครับ สิ่งนั้นคือ Master key มันเป็นได้หลายอย่างครับ เช่น เหรียญบาท ช้อนเล็กๆ ฯลฯ 
เป็น item ที่สามารถปลดล็อคประตูหลายๆห้องได้ รวมถึงห้องน้ำด้วย ก็...ต่อจากนั้นคงจะคิดภาพเหตุการณ์ออกสินะ มันเป็นสิ่งที่เลวร้ายมาก อย่างน้อยผมก็รอดมาได้ T-T 

ในค่ายก็จะมีพี่ๆค่ายมาทักทาย จัดการติว(ทรมาน)รุ่นน้อง แล้วก็จัด contest ทดสอบฝีมือกัน หลังเลิกเรียนแถวที่พักครูเขาก็จะจัดติวให้สำหรับนักเรียนที่ตามไม่ทันด้วย แต่ผมไม่ได้ไปหรอกครับ เก่งอยู่แล้ว😎 ซึ่งถึงแม้ทางค่ายจะมีอาหารให้ทุกมื้อ แล้วก็มีเบรคตลอดแบบไม่จำกัด ผมก็ยังเสียตังไปกับการสั่งข้าวสุดหรูมากินที่ห้องพักในบางมื้ออยู่ดี555 ส่วนที่พักปีนั้นถือว่าธรรมชาติมากครับ มีไส้เดือนมาทักทายทุกเช้าเลย แล้วก็มีสระน้ำด้วยนะเออ ผมไปเล่นแทบทุกวันเลย

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/44e0aa7d-8b6d-49d5-acc5-b48e143e740c" width="500px" align="center">

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/e6264861-558a-4c87-a2a4-309b480d7b60" width="500px" align="center">

ในค่ายนี้มีทั้งได้ไปเที่ยว ได้ไปกินชาบู มีกิจกรรมบอกความรู้สึกในค่ายด้วย555 ในห้องเรียนใครเครียดๆก็ไปเล่นของเล่นหลังห้องได้ ถือว่าชิวมากครับ __เหมือนมาเที่ยวเล่นมีเรียนนิดหน่อย__ พอถึงวันสอบท้ายค่ายก็นั่งรถบัสตั้งแต่เช้าเดินทางไปมข. กันยาวๆ 

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/81561ffe-f3e3-4c84-a6a8-069bf7385634" width="500px" align="center">

พอไปถึงเจอกับอีกศูนย์นึงบรรยากาศแต่ละคนก็ตึงพอสมควร พอกินข้าวเรียบร้อย อาจารย์ก็มาทักทายแล้วก็บอกกฎการสอบ 
ก่อนเดินเข้าห้องสอบผมก็ได้คิดกับตัวเองไว้ว่า ผมในตอนนี้ไม่เหมือนปีที่แล้วอีกแล้ว ครั้งนี้จะทำเต็มที่จะไม่มีเสียใจภายหลังอีก ลุยยยยยย

มีเวลา 3 ชั่วโมง โจทย์ 5 ข้อ ผมดันไปทำข้อยากสุดก่อนเลยเพราะคิดว่ามันง่าย เสียเวลาไป 50 นาที เริ่มตั้งสติได้ไปทำข้ออื่น ทำอยู่สักพักได้มา 90 คะแนน
รอดตายแล้ว มีคะแนนออก แล้วก็นั่งทำอีกข้อนึงที่เป็นโจทย์ [Maximum subarray sum](https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/) ผมเคยอ่านเจอใน [Competitive Programmer’s Handbook หน้าที่ 21](https://cses.fi/book/book.pdf) แต่ดันลืม!!!! นั่งมั่วไปจนเกือบหมดเวลา 
สรุปได้ทำแบบ O(n^2) แล้วทำการ disable synchronization between C++ and C I/O streams ทำให้เร็วขึ้นแล้วก็ได้มา 100 คะแนนเต็ม ตอนนั้นก็โล่งละ นั่งเล่นจนหมดเวลาสอบอย่างสบายใจ

พอสอบเสร็จ อาจารย์ก็มาประกาศผลคร่าวๆ ก็มีแจกรางวัลให้กับพวก top 5 ค่ายด้วย ซึ่งครูเขาก็จะบอกก่อนว่าเป็นนักเรียนศูนย์ไหน ไล่จากคะแนนมากไปน้อย พอเป็นศูนย์หนองบัวครั้งแรกทุกคนในศูนย์ก็หันหน้าจ้องมาที่ผมแบบ ไอ้นี่แน่ๆ เหมือนรู้ผลกันอยู่แล้ว5555 ผมก็ได้กระเป๋ากับแก้วน้ำมา รอเอากลับไปบูชาอยู่บ้าน พอถ่ายรูปรวมเสร็จผมก็เริ่มสังเกตุได้ครับ ในปีนั้นต่างจากปีก่อนเยอะเลย จากที่ปีก่อนต่างคนต่างกลับบ้านคุยกับแค่คนที่รู้จักกัน ปีนี้ทุกคนกลับพูดคุยและจากลากันอย่างสนุกสนาน จากที่ปีก่อนผมเดินกลับบ้านอย่างหมดหวัง ปีนี้ผมได้อันดับต้นๆกลับบ้านแบบเท่ๆ บางคนก็ได้รู้จักกับเพื่อนต่างโรงเรียน บางคนอยู่โรงเรียนเดียวกันก็พึ่งได้มีโอกาสได้รู้จักกัน บางคนก็ดีใจที่จะได้ไปต่อ บางคนก็รอไปทำตามเป้าหมายอื่นๆในชีวิต ในตอนนั้นการเดินทางใน ค่าย 1 สอวน. คอมพิวเตอร์ปีการศึกษา 2565 ที่ศูนย์สอวน. มหาวิทยาลัยขอนแก่น ของหลายๆคนก็ได้สิ้นสุดลงแล้วครับ น่าจะเป็นอีกความทรงจำที่อบอุ่นสำหรับใครหลายๆคนเลย :>

## ช่วงโดนตบก่อนไปค่าย 2

หลังจบค่ายแรกมา 2 เดือน opal_Inwza007x ก็ยังเหลิงกับตัวเองที่ได้เป็นอันดับต้นๆของค่ายสอวน. มหาวิทยาลัยขอนแก่น ตอนนี้อยู่ในช่วงที่กำลังศึกษาเนื้อหาค่าย 2 สำหรับสอวน. คอมพิวเตอร์อยู่ ซึ่งมันโคตรจะงงเลยโว้ยยยย เขาได้ไปพบกับการแข่ง [BangMod Hackathon 2023](https://www.facebook.com/BangmodHackathon) เนื่องจากเขามีความมั่นใจอยู่เต็มเปี่ยม แล้วก็อยากลองฝีมือคนนอกค่ายสอวน. ดูบ้าง เลยลงสมัครไปซะเลย พอมาดูขอบเขตเนื้อหา ก็กว้างถึงเนื้อหาค่าย 2 เลย ซึ่ง opal_Inwza007x เขาได้รับรู้แล้วว่าเนื้อหาค่าย 2 ยากมาก จึงกลัวที่จะเรียนต่อ ทำให้ในตอนนั้นยังไม่ได้เรื่อง กราฟ กับ DP แม้แต่นิดเดียว เลยค่อนข้างเผื่อใจไว้ว่าการแข่งนี้คงไปไม่รอด

รอบแรกเป็นรูปแบบออนไลน์ จะมีเป็น Easy, Medium, Hard โดยจะมีคะแนนเป็น 5, 15, 30 ตามลำดับ รวมๆแล้วมี 10 กว่าข้อนี่ล่ะ ให้เวลามา 3 ชม. 
การแข่งเริ่มขึ้นแล้ว ผมไปเริ่มทำดูข้อ Hard ก่อนเลย เพราะคงจะไม่เท่าไหร่หรอกมั้ง(???) เปิดมาเจอ DP อะไรวะเนี่ยย...ยังไม่เคยเรียน ข้ามไปดูข้อ Medium เลยละกัน 
ก็ยากพอใช้ได้แต่มันจะทันใน 3 ชม.จริงหรอ? ไปเจอข้อแนว pattern เนื่องจากมีประสบการณ์โชกโชนมาจากค่าย 1 จึงทำให้เก็บข้อนี้มาได้ แต่ว่า...นี่มันผ่านมา 2 ชม.กว่าแล้วนี่หว่า ลืมดู!!! จึงนั่งทำข้อ Easy ได้มาแค่ 2 ข้อ ก่อนหมดเวลา แล้วจากนั้นจิตก็หลุดลอยไปเลย ตอนนั้นก็ได้คุยกับเพื่อนไว้ว่าถ้าเราทำไม่ได้ก็คงไม่มีใครทำได้หรอก 
ตอนนั้นก็ได้แค่นั่งทำใจ แล้วพยายามตั้งใจเรียนเนื้อหาค่าย 2 ต่ออย่างทรมาน เวลาผ่านไปสักพัก ผลประกาศออกมาก็ได้เข้ารอบไปต่อ...

รอบสองปีนั้นคัดเหลือ 36 ทีมสุดท้ายจากทั่วประเทศ ไปแข่งที่มหาวิทยาลัยบางมด(มหาวิทยาลัยเทคโนโลยีพระจอมเกล้าธนบุรี) ก็ดีใจที่เข้ารอบครับ ได้โดดเรียนไปแข่ง 
พร้อมกับความมั่นใจเต็มเปี่ยมเพราะคิดว่าคนอื่นก็คงได้คะแนนน้อยเหมือนกัน ก็ได้เจอ เพื่อนๆ/พี่ๆ ค่ายที่มาจากสอวน. มหาวิทยาลัยขอนแก่นด้วย การแข่งเริ่มช่วงเช้า จะคัด 12 ทีมสุดท้ายเข้ารอบชิงไปแข่งตอนบ่าย กฎการแข่งก็เหมือนรอบแรก ข้ามไปตอนใกล้แข่งเลยละกัน 

เข้าห้องไปก็ยังนั่งเล่นเกม minesweeper ชิวๆรอเลย พอการแข่งในรอบที่ 2 ได้เริ่มขึ้น คราวนี้เริ่มทำจาก Easy ก่อนเลย ข้อแรกเจอ Fibo + Binary search ก็ชิวๆครับ ทำแค่ประมาณ 20 นาที เปิดไปเจอ DP แต่ข้อนี้พื้นฐาน จึงได้ลองนั่งทำ จากนั้นก็ติด BUG รัวๆ นั่งทำเกือบชม. พอไปดูข้อ Medium ก็เจอ DP ขั้นสูง รอไรล่ะครับ รีบข้ามเลย555 ไปดูข้อ Hard เป็นกราฟซึ่งเป็นข้อแจกคะแนนพอสมควร แต่ในตอนนั้น opal_Inwza007x กลัวกราฟมาก เลยรีบข้ามไปเลย แล้วก็นั่งอ่านโจทย์วนๆไปจนหมดเวลา รอบนี้จิตหลุดลอยกว่าเดิมเพราะได้มาแค่ 5 คะแนน(;-;) พอลองไปเดินส่องคะแนนทีมอื่น มีทีมนึงทำผ่านเยอะมากกก ผมก็คิดว่านี่คงเป็นพวกเข้ารอบชัวร์ หลังจากนั้นก็นั่งรอฟังประกาศ ผลออกมาคือไม่ได้ไปต่อ ทีมที่ผมไปส่องดูที่ทำผ่านเยอะๆก็ไม่รอด ตอนเดินออกจากห้องหลังถูกคัดออก ใครใส่เสื้อค่ายของมหาวิทยาลัยขอนแก่นไปแข่ง ได้กลับบ้านหมดเลย555 เท่าที่ลองถามดู เพื่อนๆ/พี่ๆ ค่ายคนอื่น ก็ทำได้ 50 คะแนน++ เลย แล้วก็เป็นอีกครั้งที่ผมได้เดินทางกลับบ้านอย่างสิ้นหวัง

ในการแข่งครั้งนี้ก็เป็นอีกหนึ่งประสบการณืที่ดีสำหรับผมเลยครับ ตอนนั้นผมก็คิดได้ว่าตัวเองก็ไม่เก่งเท่าไหร่นี่หว่า แม้ผมจะเก่งสุดในศูนย์สอวน. มหาวิทยาลัยขอนแก่น 
ก็ยังมีศูนย์สอวน. อื่นๆ แม้ปีนี้ผมจะเก่งสุดในประเทศ ก็ยังมีรุ่นพี่ปีก่อนๆ ในขณะที่ผมกลัวที่จะเรียนเรื่องใดเรื่องนึง คนอื่นๆอาจจะกำลังพัฒนาฝีมือในเรื่องอื่นๆให้เก่งขึ้นอยู่ก็ได้ 
หลังจากนั้นผมก็ไม่ลังเลที่จะเรียนเพิ่มอีกครับ ถ้าผมไม่เข้าใจเรื่องไหน ผมจะเขียนการทำงานของ Algorithm ใส่กระดาษไม่ว่าจะกี่แผ่น จะถามพี่ค่ายแม้พี่เขาจะนั่งกินซอยจุ๊อยู่ ไม่มีข้ออ้างในการเรียนสิ่งที่ผมไม่รู้แล้วครับ __ถ้าทำไม่ได้ ก็ต้องทำให้ได้__ (สำหรับใครที่กำลังพยายามอยู่ก็สู้ๆนะครับ ผมเชื่อว่าไม่มีการเรียนรู้ใดที่เกินความสามารถของมนุษย์คนนึงหรอกครับ ถ้าเราพยายามมากพอ แม้จะใช้เวลา)
 
ปล. คราวหลังก็พึ่งมารู้ว่าพวกไปแข่งส่วนใหญ่ก็เป็นเด็กสอวน. คอมพิวเตอร์ เหมือนกันนี่แหละ555

## ค่าย 2

ในค่ายนี้ผมกลับมาแบบดุเดือดเลือดพล่าน ผ่านมา 5 เดือนจากค่ายแรก ได้เรียนรู้เทคนิคมามากมายก่อนที่จะมาเข้าในค่าย 2 นี้ ปีนั้นได้เข้าที่มหาวิทยาลัยขอนแก่น เอาไปอวดเพื่อนได้555 เนื่องจากค่าย 1 ทำความเป็นอยู่ไว้ดีมาก ผมจึงคาดหวังว่าค่ายนี้จะได้กินดีอยู่ดีขึ้น ซึ่งเนื้อหาในค่ายนี้ก็ทำอะไรผมไม่ได้ครับ ผมเก็บมาหมดทุกอย่างก่อนเข้าค่ายแล้ว 😈 
ในค่ายนี้หลักๆก็มี Algorithm เยอะหน่อย ก็จะมีพวก

* Pair
* Lower_bound & Upper_bound
* Queue & Priority-Queue
* Map & Multimap
* Permutation
* DFS & BFS
* Shortest path Algorithm
* Minimum Spanning Tree
* Dynamic Programming

ในค่ายนี้จะพักกับเพื่อนๆค่ายวิชาอื่นด้วย ก็ดูวุ่นวายพอสมควร555 รถออกสัก 9 โมงเช้า กลับที่พัก 5 โมงเย็น แล้วในบางวันก็จะมีกิจกรรมต่างๆด้วย 
สำหรับอาหารเช้าหลักๆก็จะมี ไส้กรอก ไข่ดาว ไก่ทอด ปลาทอด วนๆไปครับ ส่วนข้าวมื้อเที่ยง/มื้อเย็น สักประมาณร้อยละ 93.72 จะมีไก่เป็นวัตถุดิบในมื้อนั้นครับ 
ปกติผมก็ชอบกินไก่นะ แต่นี่มันเยอะไปละ555

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/16511cab-62b7-4f41-b423-f5f92aaddf9c" width="500px" align="center">

ในค่ายนี้เนื่องจาก opal_Inwza007x ได้รับรู้แล้วว่าการเรียนเนื้อหาค่ายด้วยตัวเองมันยากลำบากแค่ไหน เลยจัดติวที่ห้องพักตัวเองซะเลย เพื่อไม่ให้รุ่นน้องทรมานกับเนื้อหาค่ายจนเกินไป ตอนนั้นใครเดินเข้ามาขอติวก็ติวให้หมดนะ555 ก็สนุกดีครับ ได้เห็นรุ่นน้องทรมาน555 

วันๆในค่าย opal_Inwza007x ก็ไม่ได้ทำไรมากครับ แค่ทำโจทย์ TOI เล่นระหว่างคาบ รอ speedrun lab แล้วก็กลับที่พักแบบชิวๆ ที่ผมขัดใจที่สุดสำหรับค่ายนี้คือ ไม่มีเลี้ยงชาบู!!!! ไม่ได้ไปเที่ยวด้วย(T^T) ในค่าย 2 นี้มีแต่วิชาการล้วนๆครับ555 ซึ่งแน่นอนว่าค่ายนี้ก็ยัง Master key กันได้ ระวังไว้ด้วยนะครับ555

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/39612b16-a985-4796-867b-5b389ed8311d" width="500px" align="center">

แต่อย่างน้อยค่ายนี้ก็ยังมีเลี้ยงหลองอยู่ ได้กินกับเพื่อนค่ายสาขาอื่นๆด้วย ทั้งวุ่นวายทั้งอร่อย555

หลังจากเข้าค่ายแบบติดสถานะว่าที่ผู้แทนมาหลายวัน ก็ถึงเวลาที่จะสอบท้ายค่ายแล้ว ในวันก่อนสอบผมก็ถามตัวเองอีกครั้ง "ผมมาในค่ายนี้ทำไม" จากแต่ก่อนผมมาเพื่อแก้แค้นเฉยๆ แต่ในตอนนี้ผมแค่อยากทำเพราะสนุก ได้สนุกที่มาเข้าค่าย ได้สนุกที่ได้พบเจอคนเก่งๆ ได้สนุกที่ได้เห็นการเติบโตของตัวเอง แค่ตั้งใจและมีเป้าหมายที่ชัดเจน ก็ทำให้ผมมาเข้าค่ายที่ใครๆก็มองว่าสุดยอดได้ เอาล่ะ..มาทำให้ดีที่สุดอีกรอบ แล้วรับตำแหน่งผู้แทนศูนย์มข. กัน!!!!

ปล. ทุกคนสามารถไปลองทำดูได้ที่ [OTOG ข้อ 859-866](https://otog.cf/problem) ถ้าพี่เขาไม่ปิดโจทย์นะ555

ก่อนที่จะได้เข้าห้องสอบผมไม่รู้สึกกดดันเลย กลับรู้สึกตื่นเต้นที่จะได้ทำโจทย์ที่ท้าทายสำหรับผม การสอบท้ายค่ายแบ่งออกเป็น 2 วัน แต่ละวันมี 4 ข้อ 3 ชม. ในตอนนั้นการสอบวันแรกก็เริ่มต้นขึ้น

เริ่มมาผมอ่านโจทย์ให้ครบทุกข้อดูก่อน จากที่อ่านดู ผมอยากทำข้อ [เราจะไปทางไหนกันดี](https://api.otog.cf/problem/doc/860) ก่อนเลย คิดไว้คงเป็น กราฟ + DP ตอนแรกก็ลองเขียนดูไปก่อนปรับนิดแก้หน่อย 30 นาที ได้เต็มแบบงงๆ [ตุ๊กๆ](https://api.otog.cf/problem/doc/859) คือเป้าหมายต่อไป เป็นประยุกต์ MST นิดหน่อย ลองทำซัก 20 นาทีละกัน อะอ่าว...ได้เต็ม 100 ซะละ ไม่รอช้าไปต่อที่ข้อ [แห](https://api.otog.cf/problem/doc/862) เป็น sieve of Eratosthenes + Sliding window แต่ในตอนนนั้นผมทำ sieve ไม่เป็น ได้มา 90 คะแนน เพราะนึกว่าเคสสุดท้ายเอาไว้ดักเฉยๆ แล้วผมก็ติดข้อ [ฝาแฝด](https://api.otog.cf/problem/doc/861) อยู่ชม.ครึ่ง ผมทำได้แค่แบบ Brute Force ได้มา 30 คะแนน ข้อนี้ใช้ Quicksum + Binary Search จบวันแรกผมก็ชิวละครับ คะแนนโดดเกิน สงสัยมีเทพ Algo เข้าสิง555(สาธุครับ) 

ในการสอบวันที่ 2 ทุกคนก็ดูไม่เครียดเท่าไหร่ เพราะใครไม่ได้ก็ปล่อยจอยละ555 เริ่มมาผมก็อ่านโจทย์ทุกข้อเหมือนเดิม เอาล่ะเริ่มทำข้อ [Penguinese](https://api.otog.cf/problem/doc/863) ก่อนเลยละกัน ลองเขียนใส่กระดาษไปมา ก็มองข้อมูลออกว่าเก็บใน Dequeue แล้วย้ายไปมาแค่นั้นเอง เขียนส่งผ่านใน 20 นาที ไปดูข้อ [ปลายัดไส้](https://api.otog.cf/problem/doc/864) ต่อ ลองทดใส่กระดาษ ข้อนี้ก็แค่ Dijkstra ประยุกต์นิดหน่อย แต่มุมมองน่าสนใจดี ใครดูข้อนี้ออกผมถือว่าคุณคงเข้าใจโจทย์กราฟทั่วไปพอสมควรแล้ว ทำอีกไม่กี่นาทีผมก็เก็บข้อนี้เต็ม ต่อมาลองดูข้อ [เปล](https://api.otog.cf/problem/doc/866) ในห้องสอบทำ Brute Force ส่งได้ 30 คะแนน ข้อนี้จนออกมาผมก็ยังทำไม่ได้ เลยให้ ChatGPT ช่วย ดันเป็น Algorithm Meet in the middle ที่ช่วยให้ข้อนี้ได้คะแนนเต็ม ซึ่งผมก็ Proof ไม่ได้เหมือนกัน แต่ใครอยากลองวิธีอื่นดูก็ดีครับ [Mitosis](https://api.otog.cf/problem/doc/865) เป็นชื่อโจทย์ที่ยากที่สุดในการสอบครั้งนั้น ใครๆก็มองออกว่าเป็น BFS แต่แค่นั้นไม่พอ ต้องมีพลัง Math + ความไม่เมาโค้ดขั้นสุดยอด ถึงทำข้อนี้ได้ ซึ่งแน่นอนว่าระดับ opal_Inwza007x ในตอนนั้นแล้ว...ก็ทำไม่ได้เหมือนกัน555 ผมก็นั่งอ่านโจทย์ 2 ข้อนั้นวนๆ จนหมดเวลา 

หลังสอบท้ายค่ายเสร็จก็มีเลี้ยง Pizza + KFC ด้วย(แซ่บๆครับ) ในค่ายนี้ทุกคนก็ดูสนิทกันขึ้นเยอะเลย ดีไม่ดีขึ้นมหาลัยอาจจะได้เจอกันก็ได้ ใครที่ยังมีปีหน้าแล้วอยากจะมาแก้แค้นก็สู้ๆนะครับ หลังจากได้ร่ำลากัน ในระหว่างทางกลับบ้าน ผมได้คิดเรื่องมากมาย ตั้งแต่ผมที่ยังเขียน Loop ไม่เป็น ผ่านมาปีกว่าก็ได้เป็นผู้แทนศูนย์ซะละ ถึงแม้ผมจะสอบได้อันดับแรกของค่าย แต่ผมจะไม่เหลิงตัวเองเหมือนแต่ก่อนอีกแล้วครับ ยังมีคนที่เก่งกว่าผมอีกเยอะ ต่อจากนี้จะพยายามเต็มที่สำหรับการไปแข่ง TOI19 ครับ orz orz orz

## The 19th Thailand Olympiad in Informatics

หลังจากจบค่ายที่แล้วมาเดือนกว่าๆ ผมก็ได้ไปเข้าอบรมค่ายติวผู้แทนศูนย์ของมข. ด้วย ทำให้ผมได้รู้ว่าอาหารที่ ตลาดมอดินแดง แซ่บมากครับ แทบจะไปกันทุกวันเลย555 แล้วก็ได้เจอกับท่านเทพ [krist7599555](https://github.com/krist7599555) แล้วก็จะมีพวกพี่ค่ายมาช่วยบ้าง ผมก็ขอขอบคุณที่ยอมสละเวลาส่วนตัวให้ครับ กราบๆ 

ในพิธีเปิดก็ยิ่งใหญ่มากๆๆ เนื่องจากมีพิธีเปิดพร้อมกับ TChO20 ซึ่งผมก็ไปนั่งเปื่อยประมาณ 4 ชม. สำหรับอาหารการกินอยู่ในระดับค่าย 2 ที่ไม่มีไก่ครับ555 
ผู้คนโดยเฉลี่ยในการแข่งโดยเฉลี่ยมักจะ(เกียน)เก่งมาก ซึ่งใครมาทักแล้วผมจำไม่ได้ก็ขอโทษด้วยนะครับ ผมไม่ค่อยจำหน้าคนครับ555

ปล. มีเฉลยแบบเทพๆจากท่าน [krist7599555](https://github.com/krist7599555/toi/tree/master/toi19) มาฝาก orz orz orz

เนื่องจากผมไม่ใช่เด็กกิจกรรม แล้วการไปแข่งในครั้งนี้ส่วนใหญ่ได้ไปเที่ยววัดที่มีแสงแดดจ้องจะสลายผิวขาวของคุณ ผมจึงขอข้ามไปในตอนแข่งเลยนะ555

ในการสอบนี้ผมก็ไม่คิดไรมากครับ ผมเชื่อว่าสิ่งที่ผมได้มาคือสิ่งที่ดีที่สุดที่ผมสามารถทำได้แล้วไม่ว่าผมจะได้หรือไม่ได้อะไรกลับบ้านก็ตาม ซึ่งผลคือได้ทองแดง แค่นั้นแหละ 
รอผมเก่งพอที่ผมจะสามารถอธิบายโจทย์ให้พวกคุณได้ก่อนนะครับ T^T

__คำเตือนเนื้อหาต่อจากนี้มีความรู้สูงหากทุกท่านต้องการมาดูแค่ประสบการณ์ ขอแนะนำให้ข้ามไป[จุดจบ](https://github.com/opalInwza007x/TEST/blob/main/README.md#%E0%B8%88%E0%B8%B8%E0%B8%94%E0%B8%88%E0%B8%9A)ได้เลยครับ__

### การแข่งขันคอมพิวเตอร์โอลิมปิกระดับชาติครั้งที่ 19 วันที่ 1 โจทย์ 3 ข้อ มีเวลาให้ 4 ชั่วโมง

__1. ผสาน (Merge)__ [ลองทำ](https://programming.in.th/tasks/toi19_merge)

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/3df0d493-2dfb-4862-ad4a-69bcdf9a565f" width="500px" align="center">

__ขอสั้นๆ :__ ขอนี้เข้าใจยากมากกกกกกกกก ผมอ่านอยู่กว่าครึ่งชั่วโมงเลย เพื่อความเข้าใจจะเปลี่ยนวิธีการอธิบายเลยละกัน มีบริษัทรถขายไอติม x และ y โดยเรามีข้อมูลว่าแต่ละบริษัทจะมีรถขายไอติมอยู่กี่คัน แต่ละคันจะอยู่ที่จุดไหนและในคันๆนั้นจะมีไอติมอยู่กี่แท่ง โดยเราจะโดนถาม q ครั้ง แต่ละครั้งถามว่าถ้าเราอยู่ที่จุด -inf จะต้องเดินไปทาง +inf อีกอย่างน้อยเท่าไหร่ ถึงจะซื้อไอติมได้ครบ k แท่ง แต่แค่นั้นไม่พอ บริษัทรถขายไอติม y ทั้งหมดจะย้ายตำแหน่งทุกๆครั้งที่โดนถาม โดยตำแหน่งจะเปลี่ยนเป็น new_position = a * old_position + b เมื่อ a, b คือ input

### Observation 1 Linear function

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/0b105e05-87d4-49bf-aaea-3727746f6144" width="500px" align="center">

ลองดูรูปนี้ดีๆครับ ผมให้แนวนอนคือตำแหน่งใดๆ และให้แนวตั้งคือจำนวนไอติมที่รถไอติมตำแหน่งนั้นมี ถ้าดูดีๆยิ่งเราอยู่ตำแหน่งขวามาก ค่าที่เราได้ก็ยิ่งมากขึ้นใช่ไหมล่ะครับ 
ถ้าพูดถึงฟังก์ชันที่เป็นเส้นตรง แน่นอนว่ามันคือ!!!! Binary Search นั่นเองเองเองเอง... แล้วเราก็ทำ quick sum จำนวนไอติมที่สะสมเอาไว้ พอได้ตำแหน่งที่จะเช็คก็จะได้ค่าใน O(1) เลย

### Observation 2 Inverse

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/f6dd9223-a4b3-4cc7-81d9-ac36bbf9f1fc" width="500px" align="center">

เพื่อความสะดวกเราจะแยกเคสของบริษัทขายไอติม x และ y ละกัน โดยบริษัทขายไอติม x เราแก้ได้ด้วยอันข้างบนละ ตอนนี้เหลือบริษัทขายไอติม y ที่เปลี่ยนตำแหน่งตลอดเวลา

สมมติเรามี array นึงที่มีค่าเป็นฟังก์ชันเพิ่ม ต้องการ Binary Search ค่า mid

เราต้องเปลี่ยนค่าใน array ทั้งหมดเป็น new_val = a * old_val + b แล้ว Binary Search ค่า mid เราต้องใช้เวลาเปลี่ยน O(n) 

แต่ถ้าเราหา inverse ได้จากการทำ old_val = (new_val - b) / a คราวนี้เราไม่ต้องเปลี่ยนค่าทั้งหมดเรา Binary Search ค่า (mid - b) / a ใน array ปกติแทนเลย

    Binary_search(change(vector), mid) = Binary_search(vector, inverse_change(mid))
    // change function Time O(n)
    // inverse_change function Time O(1)

### Solution

    #include <bits/stdc++.h>

    using namespace std;
    
    typedef long long ll;
    
    const ll maxn = 1e5 + 5;
    const ll inf = 1e9;
    
    ll arr_x[maxn], arr_y[maxn], rsq_x[maxn], rsq_y[maxn];
    
    int main() {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
    
        ll n, m, q;
        cin >> n >> m >> q;
        for (int i = 0; i < n; i++) {
            cin >> arr_x[i];
        }
        for (int i = 1; i <= n; i++) {
            cin >> rsq_x[i];
            rsq_x[i] += rsq_x[i - 1];
        }
        for (int i = 0; i < m; i++) {
            cin >> arr_y[i];
        }
        for (int i = 1; i <= m; i++) {
            cin >> rsq_y[i];
            rsq_y[i] += rsq_y[i - 1];
        }
        for (int i = 0; i < q; i++) {
            ll a, b, k;
            cin >> a >> b >> k;
            ll l = -inf, r = inf;
            while (l < r) {
                ll mid = l + (r - l) / 2;
                ll sumx = rsq_x[upper_bound(arr_x, arr_x + n, mid) - arr_x];
                ll sumy = rsq_y[upper_bound(arr_y, arr_y + m, (mid - b) / a) - arr_y];
                if (sumx + sumy < k) {
                    l = mid + 1;
                }
                else {
                    r = mid;
                }
            }
            cout << l << "\n";
        }
        return 0;
    }

ตอนสอบผมเก็บ subtasks ได้มา 38 คะแนน มัวแต่ไปเสียเวลาข้อ Jewelry แล้วก็ทำไม่ได้ด้วย555

__2. นักสำรวจ (Explorer)__ [ลองทำ](https://programming.in.th/tasks/toi19_explorer)

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/342bf9e6-dce6-4d52-a30f-c7d30023db73" width="500px" align="center">

__ขอสั้นๆ :__ ขอนี้ก็เข้าใจยากเหมือนกัน โจทย์จะให้การเดินรูปแบบเฉพาะมา แล้วเราต้องแปลงกลับเป็นกราฟ แล้วก็ใช้ math หาเส้นทางทั้งหมดที่เป็นไปได้

ข้อนี้ท่าน [krist7599555](https://github.com/krist7599555/toi/tree/master/toi19/toi19_explorer) เขียนไว้ดีมากครับ ส่วนผม BFS ใหม่หมดแม่ม

### Bruh Solution

    #include <bits/stdc++.h>
    
    using namespace std;
    
    typedef long long ll;
    
    const ll maxn = 5e5 + 5;
    const ll mod = 1e9 + 7;
    
    ll fac[maxn], child[maxn], re = 1;
    vector<ll> edge[maxn];
    bool visited[maxn] = {};
    queue<ll> qu;
    
    int main() {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
    
        fac[0] = 1;
        for (int i = 1; i < maxn; i++) {
            fac[i] = i * fac[i - 1];
            fac[i] %= mod;
        }
        ll n, x;
        cin >> n >> x;
        for (int i = 1; i < 2 * n - 1; i++) {
            ll y;
            cin >> y;
            edge[x].emplace_back(y);
            x = y;
        }
        qu.emplace(x);
        while (!qu.empty()) {
            ll nownode = qu.front();
            qu.pop();
            if (visited[nownode]) continue;
            visited[nownode] = 1;
            for (auto e : edge[nownode]) {
                if (!visited[e]) {
                    child[nownode]++;
                    qu.emplace(e);
                }
            }
            re *= (fac[child[nownode]] != 0 ? fac[child[nownode]] : 1);
            re %= mod;
        }
        cout << re;
        return 0;
    }

ข้อนี้ไม่มีไรมากครับ ขนาดตอนผมส่งได้เต็มยังงงเลย ส่วนอันโค้ดข้างบนว่างๆเดี๋ยวมาแก้ครับ เขียนเหมือนไม่ให้คนอ่านเลย555

__3. สร้อยอัญมณี (Jewelry Necklace)__ [ลองทำ](https://programming.in.th/tasks/toi19_jewelry)

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/c1bf4828-a7b1-4733-8965-cfe0aea83fda" width="500px" align="center">

__ขอสั้นๆ :__ COMING !SOON

### การแข่งขันคอมพิวเตอร์โอลิมปิกระดับชาติครั้งที่ 19 วันที่ 2 โจทย์ 3 ข้อ มีเวลาให้ 4 ชั่วโมง

__1. เติมพลังงาน (Energy)__ [ลองทำ](https://programming.in.th/tasks/toi19_energy)

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/df32d588-3b34-4609-82f0-7a2bff665ee1" width="500px" align="center">

__ขอสั้นๆ :__ ข้อนี้โจทย์ DP ธรรมดาเลยครับ ให้หาวิธีที่สร้าง binary tree ที่มี k ชั้น โดยผลรวมที่ชั้นเดียวกันจะต้องห่างไม่เกิน d mod 1e9 + 7

ข้อนี้ก็ใช้ Matrix Chain Multiplication เลยครับ ผมทำแบบ Top-Down โดยสังเกตุได้ว่าต้นไม้จะสร้างได้ทั้งหมด (จำนวนที่สร้างได้แบบซ้าย * จำนวนที่สร้างได้แบบขวา) โดยข้อนี้ถ้าไม่กำหนด memo เป็น -1 หรือมี visited จะได้แค่ 56 คะแนน เพราะจะมีบางครั้งที่ต้นไม้มันสร้างไม่ได้แล้วจะได้ค่า 0 อยู่ตลอด แล้วพอเราเช็ค if (0) มันก็จะ false แล้วก็หาใหม่เรื่อยๆอยู่นั่นแหละ จึงติด T นั่นเอง

### Solution

    #include <bits/stdc++.h>
    
    using namespace std;
    
    typedef long long ll;
    
    const ll mod = 1e9 + 7;
    const ll maxn = 305;
    const ll maxk = 15;
    
    ll n, k, d, rsq[maxn], memo[maxn][maxn][maxk];
    bool visited[maxn][maxn][maxk];
    
    ll solve(ll l, ll r, ll k) {
        if (!k) {
            return 1;
        }
        if (visited[l][r][k]) {
            return memo[l][r][k];
        }
        visited[l][r][k] = 1;
        ll sum = 0;
        for (int i = l; i < r; i++) {
            if (abs(rsq[i] - (l == 0 ? 0 : rsq[l - 1]) - (rsq[r] - rsq[i])) <= d) {
                ll l_root = solve(l, i, k - 1);
                ll r_root = (l_root == 0 ? 0 : solve(i + 1, r, k - 1));
                sum += l_root * r_root;
                sum %= mod;
            }
        }
        return memo[l][r][k] = sum;
    }
    
    int main() {
        scanf("%lld %lld %lld", &n, &k, &d);
        for (int i = 0; i < n; i++) {
            ll x;
            cin >> x;
            rsq[i] += (i == 0 ? 0 : rsq[i - 1]) + x;
        }
        printf("%lld", solve(0, n - 1, k - 1));
        return 0;
    }

ข้อนี้ไม่รู้ทำไมในห้องสอบผมคิดไม่ออก พอออกห้องมามีเพื่อนบอกให้ดูจากล่างขึ้นบน sol ขึ้นมาเต็มหัวเลย555 เก็บ subtasks มาได้ 11 คะแนน

__2. พิด’โลก (Phitsanulok)__ [ลองทำ](https://programming.in.th/tasks/toi19_phitsanulok)

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/f25c2312-b410-48e2-999f-9e2f53b6c6eb" width="500px" align="center">

__ขอสั้นๆ :__ COMING !SOON

__3. บ้านมุง (Range)__ [ลองทำ](https://programming.in.th/tasks/toi19_range)

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/cb05213f-659f-47a5-b759-f02ea4e22834" width="500px" align="center">

__ขอสั้นๆ :__ จะมีภูเขาหลายๆลูก แต่ละลูกเราจะเริ่มที่จุด l และจบที่จุด r โดยโจทย์ต้องการหาคะแนนของภูเขามากที่สุด และคะแนนของภูเขาแต่ละลูก โดยคะแนนของภูเขาใดๆคือ คะแนนของภูเขาลูกน้องที่มากที่สุด + 1 เมื่อภูเขาลูกน้องมีขอบเขตคือ ((l น้อง >= l พี่) และ (r น้อง <= r พี่)) และเมื่อภูเขาลูกพี่ไม่มีภูเขาลูกน้อง คะแนนของภูเขาลูกนั้นคือ 1

### Observation 1 LIS

> <img src="https://github.com/opalInwza007x/TEST/assets/114739286/287432e7-ae8b-43df-af77-a7ee4d0013ca" width="500px" align="center">

นี่มันนิยาม LIS นี่เอง ทำไมในห้องสอบผมถึงดูไม่ออกกันนะ555

### Solution

    #include <bits/stdc++.h>
    #define F first
    #define S second
    
    using namespace std;
    
    typedef long long ll;
    typedef pair<ll, ll> pll;
    typedef pair<ll, pll> plpll;
    
    const ll maxn = 4e5 + 5;
    
    vector<plpll> vec;
    vector<ll> ans;
    ll memo_lis[maxn];
    
    bool comp(plpll a, plpll b) {
        if (a.F == b.F) {
            return a.S.F < b.S.F;
        }
        return a.F > b.F;
    }
    
    int main() {
        ios_base::sync_with_stdio(0);
        cin.tie(0);
    
        ll n;
        cin >> n;
        for (int i = 0; i < n; i++) {
            ll x, y;
            cin >> x >> y;
            vec.emplace_back(x, make_pair(y, i));
        }
        sort(vec.begin(), vec.end(), comp);
        for (int i = 0; i < n; i++) {
            ll pos = upper_bound(ans.begin(), ans.end(), vec[i].S.F) - ans.begin();
            if (pos == ans.size()) {
                ans.push_back(vec[i].S.F);
            }
            else {
                ans[pos] = vec[i].S.F;
            }
            memo_lis[vec[i].S.S] = pos;
        }
        cout << ans.size() << "\n";
        for (int i = 0; i < n; i++) {
            cout << memo_lis[i] + 1 << " ";
        }
        return 0;
    }

ข้อนี้ถ้าดูออกเป็น LIS ก็จบเกมแล้วครับ แค่กลับด้านนิดหน่อย ผมเก็บ subtasks ได้มาตั้ง 42 คะแนนแหน่ะ555(;-;)

## จุดจบ(?)

หลังจบจากการแข่งขันมาแม้ผมจะทำดีที่สุดในแบบของผมมาโดยตลอด ในครั้งนี้ผมคงจะมาอ้างว่า "ยังไม่ได้ทำดีที่สุด" อีกไม่ได้แล้ว แต่ผมก็ยังคงเจ็บใจที่แม้จะทำดีที่สุดจนถึงตอนนั้นแล้ว ก็ยังไม่เก่งพอที่จะได้ไปต่ออยู่ดี ผ่านมาหลายวันผมก็ใช้เวลาคิดทบทวนสิ่งต่างๆที่ผ่านมาตลอดปีกว่า แล้วผมก็ได้เกิดไอเดียนึงขึ้นมา ผมจะมีช่วงที่ท้อมากในการเขียนโปรแกรม ผมควรจะเริ่มยังไง ผมจะหาโจทย์แบบนี้ได้ที่ไหน ถึงแม้ตอนนี้ผมจะผ่านมาได้หมดแล้ว แต่ถ้าเมื่อก่อนมีใครสักคนคอยนำทางให้ผมจนจบได้ก็ดี ในตอนนี้การเดินทางของผมได้จบลงแล้วครับ ผมคงต้องปล่อยวางแล้วฝากปณิธานของผมให้คนรุ่นถัดๆไป ผมอยากจะนำประสบการณ์มาเป็นแนวทางสำหรับคนที่กำลังพยายามอยู่ ผมบอกได้เลยว่าความพยายามถึงแม้บางทีจะไม่ถึงเป้าหมาย แต่ประสบการณ์ระหว่างทางนั้นเป็นสิ่งที่จะคอยพัฒนาตัวเองได้ดีสุดๆเลยครับ ถ้าเจอผมตามข้างทางก็อย่าลืมทักกันด้วยนะครับ จะได้ฝึกรับมือการเป็นคนดัง 

เอาล่ะครับ ได้เวลากล่าวจบแล้ว ผมไม่สนหรอกนะครับว่าสิ่งที่ผมเขียน จะทำให้ผมกลายเป็นที่รู้จักของใครหลายๆคนรึป่าว แต่แค่ขอให้สิ่งที่ผมเขียน มีประโยชน์กับใครสักคนก็พอ และนี่ก็เป็นจุดเริ่มต้นของ __"เส้นทางในสอวน. คอมพิวเตอร์ ของ opal_Inwza007x"__ ขอขอบคุณและสวัสดีครับ

# เนื้อหาค่าย 1 สอวน.คอมพิวเตอร์
ปล. นี่เป็นภาษา opal_Inwza007x ถ้าไม่เข้าใจ ก็ไปถาม [opal_Inwza007x](https://www.facebook.com/profile.php?id=100002974790342)

ปล2. ตัวฟ้าๆกดได้นะครับ เป็นเรื่องเพิ่มเติม

## เปิดมาหน้าแรก แต่ละอันเอาไว้ทำไร
    
    1. #include <iostream>

    2. using namespace std;

    3. int main() {
    4.     // process   
    5.     return 0;
    6. }
    
* บรรทัดที่ 1 เป็นการประกาศหัวเรื่องให้โปรแกรมรู้ ว่าเราจะใช้ฟังก์ชันในหัวเรื่องนี้นะ อารมณ์เหมือนโหลด mod เข้าเกมเลย

* บรรทัดที่ 2 เป็นการย่อโค้ดให้สั้นลง เช่น ถ้าไม่มีบรรทัดนี้เราจะต้องพิมพ์คำสั่ง cin >> x; เฉยๆ กลายเป็น std::cin >> x;

* บรรทัดที่ 3-6 เป็นฟังก์ชันที่ต้องมีทุกบ้าน ถ้าไม่มีจะ compile ไม่ติด ยกเว้นโจทย์แนว interactive ที่จะไม่มี main ก็ได้

* บรรทัดที่ 4 คือการคอมเม้นใน c++ โดยเราจะพิมอะไรหลัง // ก็ได้ 

* บรรทัดที่ 6 อันนี้ต้องอธิบายก่อนว่า ตัว compile จะอ่านโค้ดเราจากบนลงล่าง ถ้ามันเจออะไรแปลกๆมันจะบอกเราว่าตรงนี้ผิด ซึ่ง return 0; ที่เราเอาไว้ล่างสุดของการทำงาน จะทำให้ตัว compile รู้ว่าโปรแกรมนี้คืนค่า 0 ออกมา ซึ่งความหมายก็คือโค้ดนี้ไม่มีไรผิดพลาด แล้วเรายังสามารถใช้คำสั่งนี้ในการจบการทำงานโค้ดเราตอนไหนก็ได้ด้วย

## __${\color{black}Variable}$__

| ชื่อ | เอาไว้รับค่า | การนำไปใช้ | Bytes |
| :---: | :---: | :---: | :---: |
| int | -2,147,483,647 ถึง 2,147,483,647 | ไว้รับค่าตัวเลขเฉยๆตั้งแต่ -(2^31-1) ถึง 2^31-1 | 4 |
| signed int | 0 ถึง 4,294,967,295 | นิยมใช้ int มากกว่าอะ | 4 |
| long long | -9,223,372,036,854,775,807 ถึง 9,223,372,036,854,775,807 | ไว้รับค่าตัวเลขที่กว้างหน่อย ตั้งแต่ -(2^63-1) ถึง 2^63-1 | 8 |
| unsigned long long | 0 ถึง 18,446,744,073,709,551,615 | เอาไว้รับโจทย์ที่เลขมันมากๆๆ ถ้าอันนี้ไม่ได้ก็ไปใช้ [bignum](https://www.geeksforgeeks.org/bigint-big-integers-in-c-with-example/) ซะ | 8 |
| float | 1.175E-38 ถึง 3.402E+38 | เอาไว้รับค่าเป็นทศนิยม | 4 |
| double | 2.225E-308 ถึง 1.797E+308 | ทศนิยมเหมือนกันแค่ดีกว่า | 8 |
| bool | true/false | เอาไว้เก็บค่าว่าจริงหรือเท็จ โดยถ้าให้ค่าเป็น 0 จะ false นอกนั้นถือว่า true หมด แม้แต่เลขติดลบ | 1 |
| char | เอาไว้เก็บตัวอักษรเป็น [ascii](https://th.wikipedia.org/wiki/%E0%B9%81%E0%B8%AD%E0%B8%AA%E0%B8%81%E0%B8%B5) | รับค่าตัวอักษรที่มีแค่ตัวเดียวแน่ๆ | 1 |
| string | เป็น char หลายตัวๆ เหมือนเป็น dynamic char [array](https://github.com/opalInwza007x/TEST#colorgreenarray) | รับค่าตัวอักษรที่มีหลายๆตัวได้ | 1 * (ขนาดของ string) |

ในการประกาศชื่อตัวแปรก็ทำแบบด้านล่างเลย ขอแค่ชื่อไม่ตรงกับ[ฟังก์ชัน](https://www.informit.com/articles/article.aspx?p=2755729&seqNum=7)ที่ที่เขามีให้ก็ตั้งได้แน่นอนครับ ไม่งั้นคุณอาจจะได้นั่งแก้โค้ดของคุณข้ามวัน >:3 

    <ชนิดตัวแปร> ชื่อตัวแปร;
    long long n;
    bool amogus;
    
โดยเราสามารถกำหนดค่าของแต่ละตัวได้ด้วย โดยจะมีรูปแบบตามนี้เลย

    int n = 96;
    long long n2 = 696969;
    float sum = 0.0;
    double sum2 = 0.001;
    bool flg = true;
    char a = 'F'; // ในการเก็บ character ตัวเดียวจะใช้แบบนี้ 'x';
    string s = "Bro_What??!!"; // ถ้าเก็บเป็นหลายตัวค่อยใช้ "xyz" ดู " กับ ' ดีๆด้วย!!!

ในเรื่องของ ' กับ " ก็ใช้เขียนได้หมดนะครับ แต่จะใช้ ' กับตัวอักษรเดียวในกรณีต้องการใช้สมบัติของ [ascii](https://th.wikipedia.org/wiki/%E0%B9%81%E0%B8%AD%E0%B8%AA%E0%B8%81%E0%B8%B5) ซึ่งถ้าเซียนๆหน่อย แทบจะใช้อันนี้เป็นตัวเลขเลย

แล้วก็เราสามารถใช้ const <variable> <name> = <number>; เป็นการกำหนดให้ตัวแปรนั้นเป็นค่าคงที่ ผมชอบใช้นะดูเท่ดี

    const int maxn = 69420;
    // int is read/write while const int is read-only

ระวังอย่าไปเปลี่ยนค่ามันล่ะ ไม่งั้นระเบิดแน่!!!

## __${\color{black}input/output}$__

### __${\color{green}cin}$__

เป็นคำสั่งรับค่าเข้ามาง่ายๆครับ เป็นการรับค่าเข้ามาตรงๆเลย แต่อย่าลืมประกาศตัวแปรก่อนรับค่าล่ะ

    long long n;
    cin >> n;
    string s;
    cin >> s;

ถ้าต้องการรับค่าหลายตัวในบรรทัดเดียวก็ทำแบบนี้เลยครับ

    long long n;
    string s;
    char amogus;
    cin >> n >> s >> amogus;

### __${\color{green}cout}$__

เป็นคำสั่งพิมพ์ออกทางหน้าจอหลังจากรับ input ทั้งหมดแล้ว โดยเราจะพิมพ์ข้อความจากตัวแปรหรือคำอะไรลงไปก็ได้

    long long n;
    cout << "please insert n : ";
    cin >> n;
    cout << "value of n = ";
    cout << n;
    

ถ้าต้องการแสดงผลค่าหลายตัวในบรรทัดเดียวก็ทำแบบนี้เลยครับ

    char a = 'a';
    string s = "abc"
    cout << a << " " << s;

โดยในภาษา c++ จะมีการพิมพ์แบบพิเศษเรียกว่า Escape Sequences

| Escape Sequences | ความหมาย |
| :---: | :---: |
| \n | ขึ้นบรรทัดใหม่ |
| endl | ขึ้นบรรทัดใหม่ แต่ช้ากว่ามากๆ social credit -999 |

หลักๆก็มีแค่นี้แหละครับที่ได้ใช้บ่อย แต่ไปหาดู[เพิ่มเติม](https://www.ibm.com/docs/en/i/7.3?topic=set-escape-sequences)ได้

ซึ่งเมื่อเรามีการใช้ \n ก็จะทำให้ปัดบรรทัดลงได้ตามเงื่อนไขโจทย์ส่วนใหญ่

    string s = "amogus", s2 = "is", s3 = "sus";
    cout << s << "\n" << s2 << "\n" << s3;

โดยถ้าเราต้องการแสดงค่าออกมาเป็นทศนิยมก็ใช้คำสั่ง

    cout << fixed << setprecision(x); // โดย x คือจำนวนทศนิยมที่เราต้องการ เมื่อ x เป็นจำนวนเต็มที่มากกว่าเท่ากับ 0

### __${\color{green}scanf}$__

เป็นคำสั่งที่มาจากภาษา C ใช้รับค่าเข้ามาเหมือนกันแต่จะยากกว่า แลกมากับความเร็วนิดนึง โดยแต่ละตัวจะมี format specifiers หรือตัวระบุรูปแบบของแต่ละชนิดของตัวแปร 

| ชื่อ | format specifiers |
| :---: | :---: |
| int | %d |
| long long | %lld |
| unsigned long long | %llu |
| float | %f |
| double | %lf |
| bool | ไม่มีง่ะ |
| char | %c |
| string | %s (เนื่องจากในภาษา C ไม่มี string มาให้ เราจึงต้องตั้งเป็น char array แทน) |

ตัวอย่างการใช้งาน

    long long n;
    char amogus;
    scanf("%lld %c", &n, &c); // อย่าลืม & ด้วย ไม่งั้นได้แก้ยาวแน่

โดย scanf สามารถรับค่ามาโดยตัดส่วนที่ไม่ต้องการได้ อย่างเช่น โจทย์ให้รับค่ามาเป็น xAyB เมื่อ x, y คือตัวเลขที่เราต้องการ เราสามารถรับค่าแบบนี้ได้

    scanf("%lldA%lldB", &n, &n2);

### __${\color{green}printf}$__

เป็นคำสั่งมาจากภาษา C เหมือนกัน ก็แค่แสดงค่าที่บางทีก็สะดวกกว่า cin โดยเรายังคงใช้ format specifiers เหมือนเดิม

    ll n = 20;
    char a = 'z';
    printf("%lld\n%c", n, c); // ส่วนอันนี้ไม่มี & อย่าไปงงในห้องสอบล่ะ

## __${\color{black}Conditions }$__ __${\color{black}and }$__ __${\color{black}If }$__ __${\color{black}Statements}$__

ในภาษา c++ เนี่ยก็จะใช้ตรรกะเหมือนคณิตศาสตร์เลย โดยหลักๆมีดังนี้ (Colon : เป็นเครื่องหมายที่มีการใช้เฉพาะทาง มีความหมายว่า "ดังต่อไปนี้")

* a น้อยกว่า b :  ${\color{red}a < b}$
* a น้อยกว่าเท่ากับ b : ${\color{red}a <= b}$
* a มากกว่า b : ${\color{red}a > b}$
* a มากกว่าเท่ากับ b : ${\color{red}a >= b}$
* a เท่ากับ b : ${\color{red}a == b}$
* a ไม่เท่ากับ b : ${\color{red}a != b}$

ในภาษา c++ มีการเขียนคำสั่ง if ดังนี้

    if (condition) { // if condition == true do this!!!
        // process
    }

* ใช้ ${\color{red}if}$ ไว้อันแรกเลย ถ้าเกิด condtion เรา true จะทำ process ต่อเลย
* ใช้ ${\color{red}else}$ ${\color{red}if}$ เอาไว้ใช้อันรองๆมา ถ้า condition ข้างบน false แล้วอันนี้ true จะทำ process ต่อเลย
* ใช้ ${\color{red}else}$ เอาไว้ใส่อันท้ายสุด ถ้า condition ข้างบน false หมดเลย จะทำ process ต่อโดยไม่ลังเล

## __${\color{black}Math }$__ __${\color{black}in }$__ __${\color{black}c++}$__

กำหนดให้ a, b คือ constant number

| เครื่องหมาย | ค่าที่ได้ |
| :---: | :---: |
| a + b | เอา a, b มาบวกกัน |
| a - b | เอา a, b มาลบกัน |
| a * b | เอา a, b มาคูณกัน |
| a / b | เอา a, b มาหารกัน |
| a % b | เศษเหลือจากการหาร a ด้วย b |
| aeb | a * $10^b$ |

จะมีฟังก์ชันช่วยที่ได้ใช้บ่อยๆตามนี้ โดยต้อง include cmath หรือ include bits/stdc++.h ก่อน

| ฟังก์ชัน | ค่าที่ได้ |
| :---: | :---: |
| abs(x) | ถ้า x < 0 ได้ค่า -x นอกนั้นได้ค่า x |
| sqrt(x) | ได้ค่า $\sqrt{x}$ |
| pow(x, y) | ได้ค่า $x^y$ |
| __gcd(x, y) | หรม.ของ x, y |

ตัวอย่างการใช้งาน

    long long a = 6;
    long long b = 9;
    a = a + b; // สำหรับเด็กคณิตอาจจะเศร้าหน่อย แต่บรรทัดนี้หมายถึง เพิ่มค่า a ไปอีก b
    a = a * 6; // อันนี้คือคูณค่า a ไปอีก 6

โดยมีการเขียนสั้นๆด้วย อย่างเช้น

    long long a = 8;
    long long b = 4;
    a /= b; // ย่อมาจาก a = a / b
    a -= 2; // ย่อมาจาก a = a - 2
    
    // special cases ได้แค่ + กับ -

    a++; // ย่อมาจาก a = a + 1
    ++a; // ย่อมาจาก a = a + 1
    a--; // ย่อมาจาก a = a - 1
    --a; // ย่อมาจาก a = a - 1

ถ้าถามว่า a++/a-- กับ ++a/--a ต่างกันตรงไหน ถ้าเอาง่ายๆก็ ++a/--a จะทำงานเร็ว่ากว่า แต่ถ้าในการใช้งาน ++a/--a คือ บวกค่า a ก่อนแล้วค่อยเอาไปใช้งานส่วน a++/a-- คือ เอาไปใช้งานก่อนค่อยบวกค่า a ยกตัวอย่างเช่น

    long long a = 1, b = 2;
    long long x = 1, y = 2;

    b += a++ + 2;
    // ค่า a = 2, b = 5
   
    y += ++x + 2;
    // ค่า x = 2, b = 6

## __${\color{black}Loops}$__

### __${\color{green}for}$__

ในภาษา c++ มีการเขียนคำสั่ง for แบบธรรมดาดังนี้

    for (int i = 0; i < n; ++i) {
        // process
    }

* int i = 0 คือ กำหนดให้ i = 0
* i < n คือ ถ้า i < n จะทำงานไปเรื่อยๆ จนกว่า !(i < n) aka i >= n
* i++ คือ ค่า i จะเพิ่มทีละหนึ่งเมื่อจบการทำงานใน process

ถ้าให้อ่านเป็นภาษาคนก็ ตั้งแต่ i = 0 จนกระทั่ง i น้อยกว่า n ค่า i จะเพิ่มขึ้นทีละ 1

โดย for loop สามารถทำแบบหลายๆชั้นได้ด้วย นิยมไล่เป็น i j k...

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            // process
        }
    }

ถ้าให้อธิบายก็ กำหนดให้ $a_i$ เป็นการทำงานลำดับที่ i เมื่อค่าของ i = 1, 2, 3, ...n และให้ $b_j$ เป็นการทำงานลำดับที่ j เมื่อค่าของ j = 1, 2, 3, ...m โดย for แรกจะทำงานตั้งแต่ $a_1$ จนถึง $a_n$ (ทั้งหมด n ครั้ง) โดยในการทำงานแต่ละครั้งของ $a_i$ ก็จะทำงาน $b_1$ จนถึง $b_m$ (ทั้งหมด m ครั้ง) อารมณ์เหมือนเพิ่มมิติให้ภาพเลย

### __${\color{green}while}$__

ในภาษา c++ มีการเขียนคำสั่ง while แบบธรรมดาดังนี้

    while (condition) {
        // process
    }

หลักการง่ายๆก็ ถ้า condition == true ก็จะทำงานใน process จนกว่าจะ false ต่อมาคือตัวอย่างการใช้งาน

    ll q;
    cin >> q;
    while (q--) {
        // process
    }

    // ย่อมาจาก

    while (q != 0) {
        // process
        q = q - 1;
    }

ในเคสนี้สมมติมาน่าจะง่ายกว่า ถ้าหลังจากการรับค่ามา แล้วได้ค่า q = 4 ในขณะที่ q ยังไม่ false (q != 0) ก็จะทำงานใน process แล้ว q = 3 วนไปเรื่อยจนกระทั่ง q = 0 แล้วจบการวน  

### __${\color{green}do...while}$__

ในภาษา c++ มีการเขียนคำสั่ง while แบบธรรมดาดังนี้

    do {
        // process
    } while (condition);

ไม่ค่อยได้เห็นบ่อยครับ นิยมใช้กันแค่ตอนมี next_permutation กัน วิธีการใช้งานก็เหมือนอันบนๆเลย ถ้า condition == true ก็จะทำจนกว่าจะ false

## __${\color{black}Time }$__ __${\color{black}Complexity}$__

<img src="https://github.com/opalInwza007x/TEST/assets/114739286/99bd4e6d-f1f8-4808-b533-e56aff5dc503" width="385px" align="center">

มีเว็บที่อธิบายแล้วผมชอบอยู่ ไปดูกันได้ครับ [เข้าใจ Big O Notation แบบไฟลุกตีนไหม้](https://rayriffy.com/blog/big-o-notation)

ว่างๆเดี๋ยวมาเขียน เข้าเกมแปป

## __${\color{black}Data }$__ __${\color{black}structure}$__

### __${\color{green}Array}$__

Array เอาไว้ใช้ตอนที่โจทย์จะนำค่าที่รับมาหลายๆอันไปใช้ต่อ โดยมีการประกาศตัวแปรแบบนี้

    long long <name>[max_index + 1];
    // เช่น
    long long arr[505];

โดยเราสามารถกำหนดค่าเองได้ตามนี้เลย

    long long arr[5] = {2, 4, 3, 5, 7};

    // หรือว่า
    
    ll arr[5];
    arr[0] = 2;
    arr[1] = 4;
    arr[2] = 3;
    arr[3] = 5;
    arr[4] = 7;

มาทำความรู้จักกับ index ดีกว่า ในทางคอมพิวเตอร์เนี่ยจะเริ่มที่ index 0, 1, 2, ... , n - 1 ถ้าอิงตามข้างบนค่าแต่ละตำแหน่งจะเป็นแบบนี้

| indexs | ค่าของ index | Array Members |
| :---: | :---: | :---: |
| 0 | 2 | arr[0] |
| 1 | 4 | arr[1] |
| 2 | 3 | arr[2] |
| 3 | 5 | arr[3] |
| 4 | 7 | arr[4] |

อย่างเช่นถ้าโจทย์อยากนำค่าไปเก็บไว้ใน array แล้วแสดง output ทั้งหมด

    const long long maxn = 1e5 + 5; // แล้วแต่เรากำหนด จะเปลี่ยนแปลงตามโจทย์
    
    long long arr[maxn];
    long long n;
    cin >> n; // ความยาว arr ที่โจทย์ให้มา

    // ***case1***
    for (int i = 0; i < n; i++) {
        ll x;
        cin >> x; // รับค่า
        arr[i] = x; // กำหนดค่า
    }

    // ***case2***
    for (int i = 0; i < n; i++) {
        cin >> arr[i]; // รับค่าเหมือนกัน แต่สั้นกว่า
    }

    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }

โดยเราสามารถเพิ่มมิติให้ array เราได้ด้วย ตัวอย่าง

    long long arr[5][5];

การกำหนดค่าก็จะดูน่าสนใจขึ้นหน่อย แต่ส่วนใหญ่ใช้รับค่ามากกว่า

    long long arr[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

ถ้าเราจะนำไปใช้จริงก็ใช้ for loop มาช่วยตามจำนวนมิติมันเลยครับ

    const long long maxn = 1005;
    
    long long arr[maxn][maxn];
    long long row, col;
    cin >> row >> col; // ความยาว arr ที่โจทย์ให้มา ในแบบ 2 มิติ ส่วนใหญ่จะให้มาเป็น row col

    for (int i = 0; i < row; i++) {
        for (int j = 0; j < col; j++) {
            cin >> arr[i][j];
        }
    }

__ข้อควรระวัง__ หากเราเผลอเอาค่า index ติดลบ มาใข้ เราจะได้ค่า alien มา

    ll n = arr[-69];
    // right now n = 👽;

บางทีเห็นมันได้ค่า 0 แต่ก็อย่าไว้ใจมันเกินไปครับ ผมติดบั๊กมาหลายวันเพราะมันเลย T^T แล้วก็การที่เราใช้ index เกินกว่าที่ประกาศไว้ จะทำให้มันระเบิดเพราะฉะนั้น อย่าหาทำ!!!

### __${\color{green}Vector}$__

vector ใช้เหมือนกับ array เลย นิยมใช้ตอนไม่สนใจค่า index ถ้าอธิบายสั้นๆเลย vector คือ dynamic array ใช้สะดวกกว่าแต่ว่าเปราะบางกว่ามาก ทำผิดนิดหน่อยก็ระเบิดละ โดยมีการประกาศตัวแปรดังนี้

    vector<<variable>> name;
    // เช่น
    vector<long long> vec;

ส่วนการกำหนดค่าเองก็

    vector<long long> vec = {1, 2, 3...}; // ได้เรื่อยๆ ไม่มีจำกัด

    const long long maxn = 1e5;
    vector<long long> vec(maxn, 0); // กำหนดให้ตั้งแต่ index ที่ 0 ถึง n - 1 เป็นค่า 0

ถามว่าถ้าเราทำอะไรสักอย่างกับ index ที่เราไม่ได้กำหนดค่าไว้ หรือ index ติดลบ จะเกิดอะไรขึ้น? ซึ่งแน่นอนว่า...ระเบิดครับ

โดยเราจะมีคำสั่งพิเศษมาใช้กับ vector ด้วย ซึ่งแน่นอนว่าต้องจำครับ โดยต่อจากนี้จะเริ่มมีการใช้ pointer ละ ซึ่งผมใช้ไม่เป็นลองไปหาดูได้ครับ

| Function | คำอธิบาย | Time Complexity |
| :---: | :---: | :---: |
| .push_back(x) | เป็นการใส่ค่า x เข้าไปใน vector ต่อกันไปเรื่อยๆ | O(1) |
| .size() | เราจะได้ค่าของจำนวนสมาชิกใน vector ในตอนนั้น | O(1) |
| .clear() | เคลียสมาชิกทั้งหมดใน vector | O(n) |
| .front() | เข้าถึงสมาชิกตัวหน้าสุดของ vector | O(1) |
| .back() | เข้าถึงสมาชิกตัวหลังสุดของ vector | O(1) |
| .empty() | จะได้ค่า 1 ถ้าไม่มีสมาชิกใดๆใน vector นอกนั้นได้ค่า 0 | O(1) |
| .pop_back() | ลบค่าตัวข้างหลังสุด | O(1) |
| .begin() | เข้าถึงสมาชิกตัวหน้าสุดของ vector แต่เป็น iterator | O(1) |
| .end() | เข้าถึงสมาชิกตัวหลังสุดของ vector แต่เป็น iterator | O(1) |
| .erase() | ลบค่าตรงที่ค่าในวงเล็บชี้อยู่ โดยค่าในวงเล็บต้องเป็น iterator | O(n) |

สำหรับผมที่ไม่ค่อยเก่งเรื่อง pointer ตัว iterator ก็คือค่าๆนึงที่การจะใช้มัน ต้องทำวิธีพิเศษให้ได้ค่าแบบปกติมา

โดยการใช้งานในการรับค่าของผมก็จะทำประมาณนี้ครับ

    vector<long long> vec;
    long long n;
    cin >> n; // รับค่าเข้ามา n ตัว
    for (int i = 0; i < n; i++) {
        long long x;
        cin >> x;
        vec.push_back(x);
    }

    // หรือแบบนี้

    const long long maxn = 1e5 + 5; // ค่า n จากโจทย์ที่สูงสุด
    
    vector<long long> vec(maxn); // เหมือนเป็นการประกาศ index สูงสุดที่เราจะใช้
    long long n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> vec[i];
    }

 แต่ส่วนใหญ่ผมใช้แบบข้างบน ขี้เกียจไปดู maxn ของโจทย์555 ส่วนการปริ้นค่า

    vector<int>::iterator itr;
    for (itr = vec.begin(); itr != vec.end(); itr++) {
        cout << *itr << "  ";
    }

    // หรือว่า

    for (auto e : vec) {
        cout << e << " ";
    }

    // หรืออีกแบบ

    for (auto &e : vec) {
        cout << e << " ";
    }

* แบบแรกผมไม่เคยใช้เพราะมันยาวเกิน

* แบบที่สองผมใช้บ่อยเลย เพราะมันค่ด EZ

* แบบที่สามต่างจากแบบที่สองแค่ตรง & ในแบบนี้พิเศษตรงที่เราสามารถเปลี่ยนค่า vector จาก e ได้เลย แต่ถ้าเป็นแบบนั้นผมจะย้ายไปใช้ array แทนดีกว่า555

โดย string ค่อนข้างคล้ายกับ vector มากๆ พูดง่ายๆเลยก็คือ vector<char> แต่แค่ optimize กว่า

### __${\color{green}Set}$__

Set ก็เป็น Data structure ที่มีประโยชน์อยู่ โดย Set มีคุณสมบัติคือ ไม่มีสมาชิกที่ซ้ำกัน และเรียงจากน้อยไปมาก โดยมีการประกาศตัวแปรดังนี้

    set<<variable>> name;
    // เช่น
    set<long long> st;

โดยเราจะมีคำสั่งพิเศษมาใช้กับ Set ด้วย แนะนำให้จำๆๆๆ โดย C คือค่า constant ที่เพิ่มมานิดหน่อย

| Function | คำอธิบาย | Time Complexity |
| :---: | :---: | :---: |
| .insert(x) | เป็นการใส่ค่า x เข้าไปใน set โดยจะเรียงให้เรียบร้อบ | O(log(n) + C) |
| .size() | เราจะได้ค่าของจำนวนสมาชิกใน set ในตอนนั้น | O(1) |
| .clear() | เคลียสมาชิกทั้งหมดใน set | O(n) |
| .empty() | จะได้ค่า 1 ถ้าไม่มีสมาชิกใดๆใน set นอกนั้นได้ค่า 0 | O(1) |
| .pop_back() | ลบค่าตัวข้างหลังสุด | O(1) |
| .begin() | เข้าถึงสมาชิกตัวหน้าสุดของ set แต่เป็น iterator | O(1) |
| .end() | เข้าถึงสมาชิกตัวหลังสุดของ set แต่เป็น iterator | O(1) |
| .erase() | ลบค่าตรงที่ค่าในวงเล็บชี้อยู่ โดยค่าในวงเล็บต้องเป็น iterator | O(logn + C) |
| .find() | หาค่าใน set ว่าอยู่ตำแหน่งใด | O(log(n)) |

โดยเซตสามาถให้งานได้หลายสายตามนี้เลย ส่วนใหญ่เวลาใช้ set ก็เพราะอยากได้คุณสมบัตินี่ล่ะ

* mutiset สมาชิกสามารถซ้ำกันได้ และเรียงจากน้อยไปมาก
* unordered_set ไม่มีสมาชิกที่ซ้ำกัน และไม่ได้เรียงจากข้อมูลให้
* unordered_multiset สมาชิกสามารถซ้ำกันได้ และไม่ได้เรียงจากข้อมูลให้ (มีมาทำไม)
* set<<variable>, greater<<variable>>> อันนี้จะทำให้ set เรียงจากมากไปน้อย

ถ้าโจทย์อยากให้เรียงส่วนใหญ่จะไปใช้ priority queue มากกว่า แต่อันนั้นเนื้อหาค่าย 2 อะเนอะ แต่รู้ไว้ก็ดีครับ ของโกง

### __${\color{green}Stack}$__

<img src="https://github.com/opalInwza007x/TEST/assets/114739286/1c1c6d87-d834-4c59-abf4-776e18b9b13d" width="385px" align="center">

Stack ก็คล้ายๆ vector เลย แต่มีคุณสมบัติ __เข้าก่อนออกหลัง__ ให้นึกภาพว่าเรามีกล่องทรงกระบอกสูงๆ พอใส่ของเข้าไปแน่นๆ เวลาเราเอาออกมาอันแรกก็จะได้อันที่ใส่เข้าไปล่าสุดเสมอ โดยใช้งานได้ตามนี้

    stack<int> stk;
    for (int i = 0; i < 5; i++) {
        stk.push(i);
    }
    while (!stk.empty()) {
        cout << stk.top() << "\n";
        stk.pop();
    }

โดยในโค้ดจะใส่ค่า 0 1 2 3 4 ตามลำดับ แต่เวลาปริ้นออกมาจะได้ 4 3 2 1 0 จะใช้ได้ดีกว่า vector ตรงที่ pop ประหยัดเวลากว่า erase มากกกกก

| Function | คำอธิบาย | Time Complexity |
| :---: | :---: | :---: |
| .push(x) | เป็นการใส่ค่า x เข้าไปใน stack | O(1) |
| .top() | เป็นการเรียกค่าที่อยู่บนสุดออกมาใช้ | O(1) |
| .pop() | ลบตัวที่อยู่ข้างบนสุด ก็คือตัวที่ใส่ไปล่าสุดนั่นเอง | O(1) |
| .size() | เราจะได้ค่าของจำนวนสมาชิกใน stack ในตอนนั้น | O(1) |
| .clear() | เคลียสมาชิกทั้งหมดใน stack | O(n) |
| .empty() | จะได้ค่า 1 ถ้าไม่มีสมาชิกใดๆใน stack นอกนั้นได้ค่า 0 | O(1) |

โดย recursive จะคิดเป็นแบบนี้แหละ แต่ผมถนัดดูเป็นแบบแตกเป็น Tree มากกว่า

### __${\color{green}Queue}$__

<img src="https://github.com/opalInwza007x/TEST/assets/114739286/7d62c549-bd34-4e48-8784-957c617409fe" width="385px" align="center"> 

Queue ก็คล้ายๆ vector เหมือนกัน แต่มีคุณสมบัติ __เข้าก่อนออกก่อน__ อันนี้ก็นึกภาพเราไปซื้อข้าวมันไก่ร้านรองสุดท้ายที่โรงเรียนสารคามพิทยาคม แล้วเจอแถวยาวๆ เวลาเราไปก็ต้องต่อที่ท้ายแถว คนที่อยู่ข้างหน้าสุดพอได้ข้าวแล้วก็จะได้ออกก่อน ส่วนเราก็รอจนกว่าจะถึงหน้าแถว ค่อยได้กินข้าวมันไก่สุดให้เยอะที่เหมือนกลัวไม่อิ่มยันพรุ่งนี้ โดยใช้งานได้ตามนี้

    queue<int> qu;
    for (int i = 0; i < 5; i++) {
        qu.push(i);
    }
    while (!qu.empty()) {
        cout << qu.front() << "\n";
        qu.pop();
    }

โดยในโค้ดจะใส่ค่า 0 1 2 3 4 ตามลำดับ เวลาปริ้นออกมาจะได้ 0 1 2 3 4 เหมือนเดิม แล้วก็เหมือนเดิมครับ pop ของ queue เวลาดีกว่า erase มาก

| Function | คำอธิบาย | Time Complexity |
| :---: | :---: | :---: |
| .push(x) | เป็นการใส่ค่า x เข้าไปใน queue | O(1) |
| .front() | เป็นการเรียกค่าที่อยู่บนสุดออกมาใช้ | O(1) |
| .pop() | ลบตัวที่อยู่ข้างบนสุด ก็คือตัวที่ใส่ไปล่าสุดนั่นเอง | O(1) |
| .size() | เราจะได้ค่าของจำนวนสมาชิกใน stack ในตอนนั้น | O(1) |
| .clear() | เคลียสมาชิกทั้งหมดใน stack | O(n) |
| .empty() | จะได้ค่า 1 ถ้าไม่มีสมาชิกใดๆใน stack นอกนั้นได้ค่า 0 | O(1) |

## __${\color{black}Function }$__ __${\color{black}and }$__ __${\color{black}Recursive }$__ __${\color{black}Function}$__

### __${\color{green}Function}$__

ฟังก์ชันจะทำให้โค้ดเราเขียนสั้นไม่ก็มีระเบียบมากขึ้น โดยส่วนใหญ่จะเขียนไว้ข้่งบน main เลย ในภาษา c++ เราก็จะมีการสร้างฟังก์ชันง่ายๆโดยแบ่งตามฉบับผมได้ 2 แบบ

    void <function_name>() {
        // process;
    }

    // เช่น

    void solve() {
        // process;
    }

หรืออีกแบบนึง

    <variable> <function_name>() {
        // process
        return solution;
    }

    // เช่น

    int find_segment3() {
        // process
        return 0;
    }

    string get_abc() {
        return "abc";
    }

โดยใน () เราจะใช้รับค่า ตามที่เราจะส่งขึ้นไปได้เลยแต่ห้ามขาดห้ามเกิน

* แบบที่ 1 void เป็นฟังก์ชันเราไม่ต้องการค่ากลับมา ไม่เปลือง memory ใช้ดีครับเยี่ยมๆ

* แบบที่ 2 เป็น variable ไรก็ได้ โดยเราจะตั้งตามค่าที่เราอยากได้ตอน return กลับ

__${\color{green}Recursive }$__ __${\color{green}Function}$__

เป็นฟังก์ชันที่เรียกใช้ฟังก์ชันตัวมันเอง ใช้เอามาลองทุกวิธีที่เป็นไปได้ ที่นิยมนำมาอธิบายที่สุดเลยก็ Fibonacci Number ซึ่ง fibo คือเลขที่เอาสองตัวก่อนหน้านั้นบวกกันต่อกันไปเรื่อยๆ มี Base Case คือ 0 และ 1 
โดยลำดับเริ่มที่ 0 เป็น 0 1 1 2 3 5 8 13 21 34... 

<img src="https://github.com/opalInwza007x/TEST/assets/114739286/0b3a0627-75dd-46a1-9094-cf0c9c1f0a7b" width="385px" align="center">

    long long fibo(long long n) {
        if (n == 0) 
            return 0;
        if (n == 1)
            return 1;
        ll path1 = fibo(n - 2);
        ll path2 = fibo(n - 1);
        return path1 + path2;
    }

การทำงานของโค้ดเราดูได้ตามภาพเลยครับ ในโค้ดนี้จะใต่ซ้ายเรื่อยๆจนกว่าจะเจอ Base Case เลย เป็นแนวคิดแบบ stack ลองเอาไปคิดดูครับ

https://www.youtube.com/watch?v=P8Xa2BitN3I อันนี้อธิบายดีๆ ปูทางไป Dynamic programming ด้วย ซึ่งก็คือถ้า format recursive เราถูก แค่ใส่ memorization ก็ไวขึ้นละ แล้วเราก็จะเรียกมันว่า Top-Down Approach

## __${\color{black}Algorithms}$__

### __${\color{green}Binary }$__  __${\color{green}Search}$__

คลิปที่อธิบายดีมากๆ https://www.youtube.com/watch?v=MFhxShGxHWc

Binary Search คือการหาค่าภายใน O(log(n)) โดยใช้หลักการ divide-and-conquer แล้วก็มีเงื่อนไขคือ array ที่เราจะ search ต้อง sort มาก่อน 

โดยในชีวิตประจำวันเราก็ใช้ Binary Search บ่อยอยู่นะครับ เช่นการที่คุณต้องอ่านหนังสือชีวะก่อนสอบที่มี 1000 หน้า ถ้าหน้าที่ต้องอ่านคือหน้า 2-3 ก็ไม่เป็นไรหรอกครับ เปิดไปทีละหน้าก็ได้ แต่ถ้าต้องการเปิดไปหน้า 420 ล่ะครับ? แน่นอนว่าคนส่วนใหญ่จะเลือกเปิดไปกลางๆเล่มแล้วเช็คว่าหน้าที่เราต้องการมากหรือน้อยกว่าหน้าที่เราเปิดเจอ สมมติให้ตอนนี้เปิดหน้า 500 ละกัน เราก็จะรู้ว่าควรจะเปิดไปหน้าซ้ายๆต่อ แล้วหน้าขวาที่มีอีก 500 แผ่นก็จะไม่ถูก search เลย ลดไปได้ตั้งครึ่งนึง ทำแบบนี้ไปเรื่อยๆจนเจอหน้าที่เราต้องการ

__ตัวอย่างโจทย์ใน OTOG__

    [ไบนารีเสิร์ช](https://api.otog.cf/problem/doc/285)
    กำหนดให้แถวลำดับ (array) ของตัวเลขจำนวนเต็มบวกที่แตกต่างกัน N ตัว หน้าที่ของคุณคือ รับคำสั่ง
    จำนวน M คำสั่ง แต่ละคำสั่งจะกำหนดจำนวนเต็ม $\x_i$ มาให้โปรแกรมของคุณต้องหาสมาชิกในแถว
    ลำดับที่มีค่ามากที่สุดที่ไม่เกินค่าของ $\x_i$ แต่หากหาไม่ได้แล้วไซร้ก็ให้ตอบว่า -1 แทน

สามารถสรุปเป็นโค้ดดังนี้

    

### __${\color{green}Range }$__ __${\color{green}Sum }$__ __${\color{green}Query }$__ __${\color{green}or }$__ __${\color{green}Quick }$__ __${\color{green}Sum}$__

## __${\color{black}Tips }$__ __${\color{black}from }$__ __${\color{black}opal Inwza007x}$__

<details>
 <summary>กดเพื่อดูของดี >:3</summary>
     <img src="https://github.com/opalInwza007x/TEST/assets/114739286/8024923d-436d-457b-9039-050c20a66932" width="385px" align="center">
 
     You got Rickrolled's lmao
</details>

(Day#0 จะบันทึกอะไรก็ได้ ไม่ได้ขอตังใคร ยกเว้น พ่อแม่)

(Day#1 ที่งานไม่เดินเพราะผมกำลังทำวิจัยอยู่นะ ไม่ได้เล่น hypixel skyblock เลย)

(Day#2 เป็นอีกวันที่ต้องทำวิจัย แต่หิวข้าวกว่า)

(Day#3 วิจัย อ้ากกกกกกกกกกกกกก)

(Day#4 amogus is so sus)

(Day#5 ใครที่พยายามทำอะไรอยู่ก็สู้นะครับ ขอให้ผ่านไปได้ด้วยดี :)

(Day#6 เดดไลน์วิจัยทำไรผมไม่ได้!!!!)

(Day#7 peaches peaches peaches peaches peaches peaches peaches peaches peaches peaches I LOVE YOU...)

(Day#8 กด alt ค้าง แล้วกด 126 แล้วปล่อย alt จะได้ ~)

(Day#9 ่just have some inspiration today)

(Day#10 หมูกระทะแซ่บๆ)

(Day#11 orz orz orz)

(Day#12 blog เสร็จพน.แน่นอนครับ)

(Day#13 We got a number one Victory Royale Yeah, Fortnite, we 'bout to get down (get down) Ten kills on the board right now
Just wiped out Tomato Town…) 

(Day#14 ขอเวลาแปปครับ hypixel skyblock มี Rift update)

(Day#15 yeahhh boiiiii) 

(Day#16 ผมไม่รู้จะพิมไรดี) 

(Day#17 ...) 

(Day#18 ผมรอดวิจัยละ แต่อีกเดือนนึงไปแข่ง :D)

(Day#19 ผมไม่รอด💀) 

(Day#20 💀)

(Day#21 ฉันนั่งตกปลาอยู่ริมตลิ่ง...)

(Day#22 ไม่มีไรมากครับ แค่หิวข้าว)

.

.

.

<img src="https://github.com/darsaveli/Mariam/blob/main/1479814528_webarebears.gif" width="385px" align="center">
